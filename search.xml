<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DL开始前的准备]]></title>
    <url>%2F2017%2F11%2F07%2FDL%E5%BC%80%E5%A7%8B%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[环境配置 Anaconda下载和安装。 下载网址 ，选择最新版本。 安装一路默认。 安装完后，为了快速下载各种Python包，使用下列命令，添加Anaconda仓库镜像 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes 然后，比如你输入 1conda install numpy 就可以安装 numpy包。 添加第三方镜像/源 教程网站 更新 所有包 1conda upgrade --all Anaconda基础命令 管理包 conda install name——安装包 可以通过”=”来指定版本， 1eg：conda install numpy=1.0 ​ 可以同时安装多个包；安装某个包会自动安装它的依赖项 conda remove name——删除包 conda upgrade –all——更新所有包 conda uprade name——更新某个包 conda list——列出已安装的包 conda search name——不知道要安装的包的确切名字，可以搜索 管理环境 conda create -n env_name list_of_packages ——创建环境 ​ -n env_name表示指定环境的名称 后面跟着的是要安装在环境的包列表（即一次安装多个包）名称 创建环境对使用不同版本的Python很有利，可以在Python2.x和Python3.x中自由切换。例子如下 12conda create -n py2 python=2conda create -n py3 python=3 ​ 上面的写法，安装的是Python2和Python3最新版，如果想安装具体的，要写=2.x activate env_name——进入环境 在环境中，也可以用包管理的基础命令（conda install/list等） deactivate——离开环境 conda info -e/conda env list ——列出所有环境 当前正在使用的环境，会有一个* conda env remove -n name/conda remove -n name –all ——删除环境。name是环境名称 conda env export &gt; environment.yaml——把环境以及已经安装的包导出到.yaml文件 conda env create -f xxx.yaml——通过环境文件来创建环境 Jupyter Notebook操作 在Anaconda Prompt中输入 1jupyter notebook ​ 就会在浏览器中打开 改变打开的路径 输入命令： 1jupyter notebook --generate-config ​ 会 显示jupyter_notebook_config.py文件路径，打开并找到 12## The directory to use for notebooks and kernels. #c.NotebookApp.notebook_dir = &apos;&apos; ​ 改为 12## The directory to use for notebooks and kernels. c.NotebookApp.notebook_dir = &apos;你要设置的Notebook路径&apos; 关闭正在运行的notebook 在tab里的Running中 关闭 notebook的操作： shift + enter：一步一步执行 菜单的Cell-&gt;Run All：一次全部执行 ​]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件系统]]></title>
    <url>%2F2017%2F11%2F07%2FLinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件系统1.分层第一层：虚拟文件系统(VFS) 第二层：具体文件系统（FATFS等） VFS封装底层，向C标准库提供系统调用接口 I/O操作Linux将设备当作文件来处理。 1.分类非缓冲式I/O操作：系统调用提供 缓冲式：C标准输入输出库函数提供 非缓冲式用“文件描述符”来表示文件 2.文件标识符0——标准输入，从键盘输入 1——标准输出，输出到终端 2——标准错误，存放错误信息的堆栈 3.标准I/O三种缓冲类型：全缓冲、行缓冲、不带缓冲 文件指针：文件的各种信息存在结构体FILE中，流（stream）用指针FILE *来描述 4.文件和目录操作文件类型： 目录文件（directory file） 普通文件（regular file） 字符设备文件（char device file） 块设备文件（block device file） FIFO 套接字（Socket） 符号链接（symbolic link） 文件访问权限：用ls -l会看到文件具体信息，最前方的是10个字符的字符串表示文件类型和访问权限 123-rwxr-xr-x 1 root root 6444 09-22 15:33 shmwrite-rw-r--r-- 1 root root 1443 09-22 15:33 shmwrite.cdrwxr-xr-x 2 root root 4096 09-22 17:19 test ​ 第一个字符表示文件类型。d代表目录，-代表非目录 。 后边的都是三个字符为一组权限， ​ 分三组。依次表示，所有者权限（当前用户），同组用户权限，其它用户权限。 ​ r,读权限；w，写权限；x，可执行权限；-没权限。** 文件属性：判断文件存不存在可以用stat/open。 ​ stat结构体：st_mode——判断文件类型，比如是不是可执行文件]]></content>
      <categories>
        <category>Linux知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LearingGroupup_Introduction]]></title>
    <url>%2F2017%2F11%2F06%2FLearingGroupup-Introduction%2F</url>
    <content type="text"><![CDATA[常见概念的关系范围：人工智能&gt;机器学习&gt;深度学习。 机器学习是实现人工智能的方法，深度学习是实现机器学习的技术 提问的智慧网址 不要因为第一次搜索没找到答案/找到太多答案，就将所有问题一股脑抛出 ​ 参考资源书籍：周志华《机器学习》、李航《统计学习方法》 视频：台湾大学. 林轩田， Machine Learning Foundations 和 Machine Learning Techniques​ 台湾大学. 李宏毅， Machine Learning 和 having it deep and structured​ Stanford. CS231n: Convolutional Neural Networks for Visual Recognition]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>基础介绍、学习资源、 提问的智慧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下GCC编译]]></title>
    <url>%2F2017%2F10%2F30%2FLinux%E4%B8%8BGCC%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[gcc + 文件名.c 将.c文件预处理、汇编、编译、链接生成可执行程序 默认生成a.out可执行程序 gcc xx.c -o xx 同样也是预处理、汇编、编译链接 -o 指定输出文件的文件名。 gcc -O2 xx.c -o xx -O[1-3] 使用编译优化来编译程序，优化等级1-3，级别越大优化效果越好 gcc -c xx.c 生成.o文件，然后可以用gcc xx.o -o xx生成可执行文件 使用的时候，直接用2或3种方法就好了。写一句话，就完成，不用像老师写这么多句的。]]></content>
      <categories>
        <category>Linux知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux命令]]></title>
    <url>%2F2017%2F10%2F30%2FLinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ls 显示当前目录下的文件和目录 -l 详细信息 -a 输出包括隐藏文件 mkdir 创建目录 -p 无父目录，一起创建。 mkdir test/tmp -p cp 拷贝 例子：cp 文件1 文件2 复制文件1内容到文件2 mv 移动或重命名 例子：mv 文件名1 文件名2 把名字改成文件名2 rm 删除文件 -r 删除子目录以及文件。 没有该参数的话 无法删除目录 -f 强制删除 echo 内容 &gt;文件名 cat 文件名 查看文件内容 ~ 表示主目录 clear 清屏 pwd 显示当前目录 输出格式是”/xx/xx” kill 关闭进程 top 动态进程列表 按q退出 man + 命令名称 显示命令帮助 （命令不会，找男人） tar -c 打包 -x 解压缩 -z gzip压缩格式 -j bzip2格式 -v 显示压缩/解压缩过程 -f 指定输出文件名 ​ 注意：打包后，后缀是.tar 打包并压缩后缀才是.tar.gz或.tar.bz2 例子： 打包并压缩 tar -czvf 指定生成的名字&lt;.tar.gz&gt; 要压缩的文件(夹) 解压缩：tar -xzvf 压缩文件名&lt;.tar.gz&gt;]]></content>
      <categories>
        <category>Linux知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令格式]]></title>
    <url>%2F2017%2F10%2F29%2F%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[[]——表示可选参数&lt;&gt;——表示必须 参数的格式：第一种：参数用-的说明后面的参数是字符形式（Unix 风格）。第二种：参数用–的说明后面的参数是单词形式（GNU 风格）。第三种：参数前有横的是 System V风格。第四种：参数前没有横的是 BSD风格。]]></content>
      <tags>
        <tag>Linux、git、命令提示格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github和git命令总结]]></title>
    <url>%2F2017%2F10%2F29%2FGithub%E5%92%8Cgit%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Github1.仓库用于存放项目 2.分支master：主分支，存放最终版本代码 其他分支：对主分支的拷贝，我们在其他分支修改再合并到master。 在分支中对某个文件修改，然后Cmommit Changes就可以修改。 3.请求代码合并pull request：子分支请求和master分支进行合并，确认之后可以提交 merge pull request：确认合并到master。 如果想要删掉已经合并的分支，Delete branch 4.fork把一个repo拷贝到你的页面，你也持有该仓库的一个副本 5.watch该仓库有变更时，可以收到邮件提醒。 6.star收藏 工作流程fork一个repo作为自己的副本-&gt;用git命令修改、管理该仓库（git add 、git commit 、git push） -&gt;发起pull request，就可以把自己的修改提交给原始仓库管理者 git命令1.git clone https：//先去repo页面点绿色的Clone or download ，复制地址 然后就可以在某个文件夹，右键-&gt;git bash使用命令 git clone + 已复制的https地址 上面的只能创建master分支。如何指定特定分支？ eg：git clone -b feature-edits https://github.com/Faith-Uchiha/hello-world.git git clone 分支名 repo https地址 2.git pull拉取该分支最新内容，与本地（当前电脑、文件夹）对比。就是更新该分支的。 3.git addgit add .——添加所有目录 git add 文件名——添加文件 注意此命令只是添加到了git队列，并没有真正上传到仓库分支 即使不是添加新文件，而是在旧文件上修改，想要更新到分支上，也要git add git commit git push 4.git commit -am-am 后面跟上注释，双引号 5.git push真正添加到分支。]]></content>
      <categories>
        <category>Github和git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类加载和初始化顺序的问题]]></title>
    <url>%2F2017%2F09%2F30%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题再现在为坦克大战的坦克增加血条显示时，采用内部类BloodBlock + 构造方法的写法，这时问题来了，发现血条怎么都画不出来。 下面是问题代码。 TankWar.java中1Tank myTank = new Tank(400,300,true,this); Tank.java中12345678910111213141516171819202122232425262728293031323334353637private int x,y;BloodBlock bb = new BloodBlock(x,y);//感觉参数没传递进去？ public Tank(int x, int y, boolean good) &#123; this.x = x; this.y = y; this.good = good; &#125; public Tank(int x, int y,boolean good,TankFrame tc) &#123; this(x,y,good); this.tc = tc; &#125; public Tank(int x, int y,boolean good,Tank.Direction dir,TankFrame tc) &#123; this(x,y,good,tc); this.dir = dir; &#125; private class BloodBlock &#123; int x ,y; public BloodBlock(int x,int y) &#123; this.x = x; this.y = y; &#125; public void draw(Graphics g) &#123; Color c = g.getColor(); g.setColor(Color.RED); g.drawRect(this.x, this.y-20, WIDTH, 20); g.fillRect(this.x, this.y-20, getLife()*WIDTH/100, 20); g.setColor(c); &#125; &#125; 很自然的将调用过程理解为，调用Tank()构造方法，将400,300传递给内部成员变量x,y； 然后再调用BloodBlock的构造方法，将Tank的x,y赋值给BloodBlock的x,y；画出血条。 实际上，执行过程并不是如此 问题解决这里就涉及到类加载和初始化的顺序问题。 初始化顺序为：静态域（静态变量，静态代码块）-&gt;动态域（成员变量，普通代码块）-&gt;构造器。 1.初次主动使用某各类时，会加载类，此时为static变量分配内存，并设置默认值（0，null，false）。然后开始初始化static域：静态域中各部分执行的先后顺序与代码先后顺序有关（也就是说，静态代码块和静态变量，谁先执行，要看谁写在前面） 2.然后是执行成员变量的初始化和代码块：执行先后顺序也是与代码位置有关 3.最后构造器。 所以，上面的错误原因就是，在成员变量bb初始化的时候： BloodBlock bb = new BloodBlock(x,y); 这里还未执行Tank的构造方法，所以这个时候Tank的x,y并未赋值，为默认值0。 改正：可以把new BloodBlock(x,y);这句话放入Tank()的构造方法里。 实际上后面测试发现：如果用构造方法的话，血块就会固定在初始位置，然而血块应该是跟随Tank移动的，所以直接用Tank的x,y就好了 不用自己写构造方法。 例子可参考:阿里巴巴14年校招附加题的解析看了这个例子会对初始化过程有更深入的了解。]]></content>
      <categories>
        <category>Java问题汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaSE练手项目之问题]]></title>
    <url>%2F2017%2F09%2F28%2FJavaSE%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%E4%B9%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天在使用 java.util.Random类产生随机数的时候，遇到一个问题。 以下是出问题的代码 123456if(mis_step==0)&#123; mis_step = r.nextInt(5); this.fire();&#125;mis_step --; mis_step在对象new出来之后，成员变量已经用r.next(5)初始化。 在Debug中运行发现：Wacth窗中观察，mis_step会在运行一段时间之后变为负数，过了一会儿又变回了正数。 解决：变为负数的原因是，nextInt(Bound) 返回的值是0~Bound-1的Int类型数 很有可能在if的 mis_step = r.nextInt(5)这个赋值语句中得到0值，随后mis_step –就会变为负数，然后就死掉，不会再有重新复制的机会，炮弹再也不会发出。 看到变回正数的原因是：其实看到的是下一个Tank的mis_step了，而不是自身自动回复。 所以,为了避免出现负数，一般的用法都是 r.nextInt(Bound)+XX]]></content>
      <categories>
        <category>Java问题汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaSESocket编程之问题]]></title>
    <url>%2F2017%2F09%2F16%2FJavaSESocket%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题1从标准输入流（即控制台输入）读取字符，不能使用ReadUTF()方法，否则会读取不进来。 问题2使用BufferedReader类的readLine()方法读取System.in的输入之后， 再用WriteUTF()发送给Server，server用ReadUTF()读的话，会抛异常。 解决办法对于问题1改用BufferedReader的ReadLine() 对于问题2尚未解决。个人猜测：因为编码不一样，WriteUTF/ReadUTF是要求Unicode编码，而中文操作系统，从标准输入流输入的应该是GBK编码 待以后深入学习Java能够看Java源码的时候再来解决。 问题2解决：真正的原因并不是编码的问题，即使client端改为PrintWriter类的println方法，server端改为BufferedReader类的readLine()方法，还是会有异常！ 而是没有调用flush()方法！！！。缓冲区没满，不调用flush()，输出流是不会输出的。所以才会抛出异常。 重要： flush()方法何时使用：涉及到缓冲区的类，都应该使用。 建议除了FileOutputStream和FileWriter类，BufferedWriter、DataOutputStream、PrintWriter、ObjectOutputstream等输出流都应该写flush()。 File***输出流是以二进制的形式写入的，所以flush()调用也无效果，可用可不用。 FileOutputStream()没有重写flush()，所以没效果]]></content>
      <categories>
        <category>Java问题汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针1]]></title>
    <url>%2F2017%2F08%2F22%2F%E6%8C%87%E9%92%881%2F</url>
    <content type="text"><![CDATA[之前学C语言的时候，指针这一块总觉得很难，一直没有信心完全弄明白。 看过一遍书之后，知识点记得几天然后马上就忘记了。 这次争取完全理解，并且能够熟练应用！]]></content>
      <categories>
        <category>C语言巩固——《C和指针》读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2F2017%2F08%2F16%2FFirst%2F</url>
    <content type="text"><![CDATA[这是我建博客后尝试写的一个.md测试 遇到的坑1.yilia主题的所有文章按钮总算是所有东西都弄好了，弄“所有文章”的显示的时候，竟然报错 ERROR plugin load failed hexo-generator-json-content 后来才发现，原来是因为我的node.js的版本太低了 原来我用的是yilia主题，后来发现categories和tags怎么都搞不好。 最后就换了next主题 2.next主题添加站内搜索hexo-generator-searchdb这个也安装了： 1$ npm install hexo-generator-searchdb --save 站点配置文件也改了： 12345search: path: search.xml field: post format: html limit: 10000 一直无法搜索，原来还少了最后一步：主题配置文件 12local_search: enable: true 3.Markdown语法问题使用“```” 这个字符的时候，最好第一个“```”之后，（这里的`是用转义字符“\”打的）回车再写文本 不然很容易和下一个要引用的段穿在一起 还有#后面要空格才能接文本]]></content>
      <categories>
        <category>初入博客</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>初次尝试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>

---
title: 类加载和初始化顺序的问题
date: 2017-09-30 15:53:43
update: 2017-09-30 17:14:43
categories: Java问题汇总
tags:
---

## 问题再现

在为坦克大战的坦克增加血条显示时，采用内部类BloodBlock + 构造方法的写法，这时问题来了，发现血条怎么都画不出来。 下面是问题代码。

<!-- more -->

TankWar.java中
```
Tank myTank = new Tank(400,300,true,this);
```

Tank.java中
```
  private int x,y;
  BloodBlock bb = new BloodBlock(x,y);//感觉参数没传递进去？
    public Tank(int x, int y, boolean good) {
        this.x = x;
        this.y = y;
        this.good = good;
    }
    
    public Tank(int x, int y,boolean good,TankFrame tc)
    {
        this(x,y,good);
        this.tc = tc;
    }
    
    public Tank(int x, int y,boolean good,Tank.Direction dir,TankFrame tc)
    {
        this(x,y,good,tc);
        this.dir = dir;
    }

    private class BloodBlock
    {
        int x ,y;
        public BloodBlock(int x,int y)
        {
            this.x = x;
            this.y = y;
        }
        public void draw(Graphics g)
        {
            Color c = g.getColor();
            g.setColor(Color.RED);
            g.drawRect(this.x, this.y-20, WIDTH, 20);
            g.fillRect(this.x, this.y-20, getLife()*WIDTH/100, 20);
            g.setColor(c);
        }
    }
```

很自然的将调用过程理解为，调用Tank()构造方法，将400,300传递给内部成员变量x,y； 然后再调用BloodBlock的构造方法，将Tank的x,y赋值给BloodBlock的x,y；画出血条。

实际上，执行过程并不是如此

## 问题解决

这里就涉及到类加载和初始化的顺序问题。 

**初始化顺序为**：静态域（静态变量，静态代码块）->动态域（成员变量，普通代码块）->构造器。

1.**初次主动使用**某各类时，会加载类，此时为static变量**分配内存**，并设置默认值（0，null，false）。然后开始**初始化static域**：静态域中各部分执行的先后顺序与代码先后顺序有关（也就是说，静态代码块和静态变量，谁先执行，要看谁写在前面）

2.然后是执行成员变量的初始化和代码块：执行先后顺序也是与代码位置有关

3.最后构造器。

所以，上面的错误原因就是，在成员变量**bb初始化的时候**： BloodBlock bb = new BloodBlock(x,y);  这里还**未执行Tank的构造方法**，所以这个时候Tank的**x,y并未赋值**，为默认值0。

改正：可以把new BloodBlock(x,y);这句话放入Tank()的构造方法里。

实际上后面测试发现：如果用构造方法的话，血块就会固定在初始位置，然而血块应该是**跟随Tank移动的，所以直接用Tank的x,y就好了** 不用自己写构造方法。
  
例子可参考:[阿里巴巴14年校招附加题的解析](http://www.cnblogs.com/echo1937/p/6242578.html)
看了这个例子会对初始化过程有更深入的了解。